# Home Assistant Integration with WAGO PLC 750- series

This integration makes use of the webvisu protocol used by the web visualisations as proviced by CoDeSys V2.3.  It offers a much greater flexibility than MODBUS as there is no need to prepare / publish specific addresses.  Direct access to all variables (even internal ones) is possible (=> be careful what you do...).

It has been built thanks to the guidance of https://github.com/msp1974/HAIntegrationExamples. @msp1974 I couldn't have done it without you.

Once you add this integration and provide the PLC IP address, the following steps are needed:

**1. Generate a sym file**

CoDeSys 2.3 can dump a registry of all the variables used in your program with their types and addresses. This integration uses it for communication.  The benefit of this approach is that you have access to every single variable of a program or a function block. The disadvantage is that once you change your program in a way that moves variable addresses, the symbol file needs to be updated again to HA.

Go to Project -> Options -> Symbol configuration and check "Dump XML symbol table"
The button "Configure symbol file" lets you select the variables to be exported (check "Export variable object") or... just export everything

The file will be generated by CoDeSys once you build your program.  It should be in the same directory as your program file with "SYM_XML" extension.  

Open it and copy the whole content (CTRL+C)

**2. Paste the sym file to Home Assistant**

Click the configuration button of the integration and chose "Symbol file" option.  Paste the whole content of SYM_XML file and click "Confirm". It the file is correct, it will be storred and used for device definitions

**3. Add devices (Otions -> Devices)**

Enter the device definitions in YAML as described below 

## Device definitions

### Lights

The basic definition of a light looks as follows:
```
  - device_name: Kitchen Light  # Name to be displayed in HA
    device_id: Light_1PP1       # Unique id, I use Fb name from Codesys
    device_type: ON_OFF_LIGHT   # This tells the integration it is a light
    u_state_addr: .OUT29        # Address for using ligt status
    change_addr: PLC_PRG.LIGHT_1PP1.external  # Address to write to to switch the light
    change_type: value          # How to swithch the light
```
The last attribute is optional and understands two values: 
* "tap" - sends "1" to change_address each time you want to swith,
* "value" - sends "1" for ON and "0" for OFF

You can extend the definition of a light by adding configuration entities:
```
    setting_auto_off_delay_addr: PLC_PRG.LIGHT_1PP1.auto_off_delay    # senconds to automatically turn off
    setting_auto_off_after_move_delay_addr: PLC_PRG.LIGHT_1PP1.auto_off_after_move_delay  # seconds to turn off after auto-on
    setting_auto_off_addr: PLC_PRG.LIGHT_1PP1.auto_off  # is the auto-off active
    setting_auto_on_addr: PLC_PRG.LIGHT_1PP1.auto_on    # is the auto-on active
```
Those settings fit the Function Block on the side of the PLC program so might not exist or work differently in your installation.  I use a custom Fb I wrote to consolidate all the functions I needed (change state by writing specific value because "tapping" sometimes produces unexpected results, add reactions to movement sensor and auto-off functionality)

### Blinds

The basic definiotion of a blind looks as follows:
```
  - device_name: Kitchen Blind 1                  # Name to be displayed in HA
    device_id: Blind_1PP1                         # Unique id, I use Fb name from Codesys
    device_type: BLIND                            # This tells the integration it is a blind
    u_is_opening_addr: .OUT41                     # Address for chcecking if blind is moving up
    u_is_closing_addr: .OUT42                     # Address for chcecking if blind is moving down
    u_position_addr: PLC_PRG.Control_B_1PP1.POS   # Address for checking the current position
    open_addr: PLC_PRG.VIS_B_1PP1_UP              # Address for initiating upward movement
    close_addr: PLC_PRG.VIS_B_1PP1_DOWN           # Address for initiating downward movement
    go_to_pos_addr: PLC_PRG.VIS_B_1PP1_SHADE      # Address for initiating movement to exact position
    set_pos_addr: PLC_PRG.Input_B_1PP1.PI         # Address for setting the desired position
```
In my instalation I use the blind control provided by OSCAT Building libraries.  Your installation might work differently.\
I am open for requests to adjust this device definition to work with other function blocks

You can extend the definition of a blind by adding configuration entities:
```
    setting_time_up_addr: PLC_PRG.Control_B_1PP1.T_UP            # Address for defining the time of upward movement in sec.
    setting_time_dn_addr: PLC_PRG.Control_B_1PP1.T_DN            # Address for defining the time of downward movement in sec.
    setting_time_power_addr: PLC_PRG.Input_B_1PP1.MAX_RUNTIME    # Address for defining the time of powering the blind motor in sec.
    setting_shade_start_angle_addr: PLC_PRG.Shade_B_1PP1.HORZ1   # Address for defining the sun position to start auto-shade functionality
    setting_shade_end_angle_addr: PLC_PRG.Shade_B_1PP1.HORZ2     # Address for defining the sun position to end auto-shade functionality
    setting_shade_position_addr: PLC_PRG.Shade_B_1PP1.shade_pos  # Address for defining the desired blind position when auto-shade activates
    setting_shade_delay_addr: PLC_PRG.Shade_B_1PP1.shade_delay   # Address for defining the delay to act when auto-shade is activate
```
### Sensor

```
  - device_name: Light South           # Name to be displayed in HA
    device_id: LIGHT_SOUTH             # Unique id, I use Fb name from Codesys
    device_type: ILLUMINANCE_SENSOR    # This tells the integration what type of sensor it is
    u_data_addr: SensorReader.L_South  # Address for chcecking sensor reading
    divisor: 1                         # Optional - divisor of values provided by the PLC
    unit: lux                          # Optional - if left out the default for each sensor type will be assigned
```
Allowed device_types are: "ILLUMINANCE_SENSOR", "TEMPERATURE_SENSOR", "POWER_METTER"\
Allowed units are: "Lux", "Celcius", "Watt" (NOTE: to be extended)


### Number Setter
```
  - device_name: Target Temperature Kitchen     # Name to be displayed in HA
    device_id: TEMP_SET_1SA                     # Unique id, I use Fb name from Codesys
    device_type: TEMPERATURE_SETTER             # This tells the integration it is a Temeprature Setter
    u_data_addr: PLC_PRG.TEMP_H1SA              # Address for chcecking/writting the setting
    mode: box                                   # Optional: Widget type
    unit: celcius                               # Optional: Unit mark to display as sufix
    divisor: 10                                 # Optional - divisor of values provided by / sent to the PLC

```
Allowed device_types are "TIME_SETTER", "TEMPERATURE_SETTER", "ANGLE_SETTER", "DISTANCE_SETTER", "GENERIC_SETTER"\
Allowed modes are: "slider", "box"\
Allowed units:  "hours", "minutes", "seconds", "celcius", "degree", "meter", "none" (NOTE: to be extended)
    





